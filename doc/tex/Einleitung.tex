% !TEX root = Projektarbeit.tex

\chapter{Einleitung}
Im gerade aufstrebenden Gebiet der eingebetteten Systeme spielt \textsc{Linux} nicht nur als schlankes, gut portierbares Betriebssystem eine tragende Rolle. Auch die Möglichkeit neue Hardware, beispielsweise Sensorik einfach in bestehende Systeme integrieren zu können macht Linux zu einer interessanten Plattform. 
Während in es in vielen Fällen ausreicht solche Hardware über sehr gut dokumentierte und einfach zu verwendende Schnittstellen im \texttt{Userspace} anzusprechen, gibt es doch Anwendungsfälle die Hardwaretreiber im \texttt{Kernelspace} erfordern. 

cZu genannten Fällen zählen beispielsweise zeitkritische Treiber, die darauf angewiesen sind priorisiert und zu festen Zeitpunkten abgearbeitet zu werden, oder auch Hardwaretreiber im \textsc{Android}-Umfeld, die schon aufgrund des Designs des Systems beziehungsweise der Rechteverwaltung nicht im Userspace laufen dürfen. \newline

Diese Projektarbeit soll sich mit solch einem Kerneltreiber auf einem eingebettetem System beschäftigen und exemplarisch darstellen, wie ein Linux-Treiber aufgebaut ist und funktioniert. Dazu wird an einem \textsc{Beaglebone Black}, einem eingebetteten Entwicklerboard, über die \texttt{UART}-Schnittstelle ein e-Paper-Display durch ein Linux-Kernel-Modul angebunden. Das Modul soll dem Nutzer die linuxtypischen Treiberschnittstellen bereitstellen, um die Kommunikation mit der Hardware zu ermöglichen.

Der Fokus soll hierbei vor allem auf allgemeinen Prinzipien und Funktionsweisen von Linux-Treibern liegen und erklären was in diesem komplexen, wenig bekannten Bereich ablaufen muss um Hardware so selbstverständlich verwenden zu können, wie dies in heutigen Linux-Systemen der Fall ist. 
%Auf der vollständige Implementierung des Treibers liegt nicht das Hauptaugenmerk.

\chapter{Hardware}

\section{Beaglebone Black}
Zur Durchführung der Projektarbeit wird das \textsc{Beaglebone Black}, ein eingebettetes Entwicklerboard auf Basis des ARM-Prozessors AM335x von \textsc{Texas Instruments} eingesetzt. Das Beaglebone bietet mit einer Taktrate von 1GHz (Singlecore), 512MB RAM und vielen zugänglichen Hardware- und Debug-Schnittstellen, sowie einer sehr guten Dokumentation ideale Voraussetzungen zur Hardwareintegration. 
%Bild Beaglebone

\section{Waveshare e-Paper-Display}
Bei dem e-Paper-Display handelt es sich um ein Modell des Herstellers \textsc{Waveshare} mit einer Auflösung von 800 x 600 Pixeln und einer Größe von 4,3 inch, dass sehr einfach über die bekannte \texttt{UART}-Schnittstelle angesprochen werden kann. 
%Was ist e-Paper, warum gewählt
%bild display

\chapter{Aufbau und Vorbereitungen} %Vorläufiger Titel
Das \textsc{Beaglebone} wird mit \textsc{Ubuntu}-Linux und dem Kernel %hier Kernel version einfügen
betrieben. Dabei ist der Treibercode nicht von einer Linux-Distribution abhängig. 

Zuerst wurde für diese Arbeit zu Beginn ein \textsc{Arch}-Linux System mit einem Mainline-Kernel der Version ... benutzt, da dieses Setup größtmögliche Freiheit in der Konfiguration des Systems und der Verwendung von \textsc{Custom-Kernels} bot. Leider gab es in dieser Konfiguration ein Problem bei der Verwendung der benötigten \texttt{UART}-Schnittstellen dessen Lösung den Rahmen dieser Arbeit sprengen würde und einen Wechsel unvermeidlich werden lies.

Der Treiber wird für die Kernelversionen 4.x der \textsc{ARM}-Plattform geschrieben und ist, solange es keine größeren Änderungen der verwendeten APIs gibt, für jeden entsprechenden Kernel kompilierbar.

\section{Aufbau der Hardware}
Das e-Paper Display besitzt ein \texttt{UART}-Interface, welches die Kommunikation zwischen \textsc{Beaglebone} und Display über zwei Pins ermöglicht. Dazu wird die \texttt{DIN}-Leitung des Displays an den \texttt{TXD}-Pin des \texttt{UART-1}-Interface des \textsc{Beaglebones} angeschlossen. Ebenso wird mit der \texttt{DOUT}-Leitung und dem \texttt{RXD}-Pin des gleichen Interfaces verfahren. Die Leitungen \texttt{RST}, der Reset und \texttt{WAKEUP} des Displays werden an den \texttt{GPIO}\footnote{Fußnote zu GPIO schreiben}-Schnittstellen des \textsc{Beaglebone} angelegt und sorgen dafür, dass der Displayinhalt gelöscht, bzw. das Display aus einem Ruhezustand geholt werden kann. Zuletzt müssen noch Versorgungsspannung (\texttt{VCC}, 5V) und Erdung (\texttt{GND}) an die entsprechenden Pins des \textsc{Beaglebone} angeschlossen werden.  

Das \textsc{Beaglebone} selbst wird über ein USB-Kabel an den Hostrechner angeschlossen und kann darüber über das \texttt{ssh}-Protokoll erreicht werden. Um die zusätzliche Hardware versorgen zu können, muss das Board zusätzlich über ein 5V-Netzteil mit Strom versorgt werden. Um schon ab dem Bootvorgang Kernellogs zeitgleich lesen zu können wird die serielle Debugging-Schnittstelle des \textsc{Beaglebone} mithilfe eines USB-Serial-Wandlers und dem Programm \texttt{Minicom} ausgelesen. 

%Bild Hardwareaufbau/Anschlüsse usw

\section{Vorbereitungen zum Coding} %Titel ändern!
Kernelmodule müssen genau zu der Kernelversion, also den Schnittstellen genau des Kernels passen auf dem sie ausgeführt werden sollen. Daher müssen die Quelltexte des Kernels vorliegen um dafür ein Kernelmodul zu erstellen. Sind Zielsystem des Treibers und dass auf dem das Modul kompiliert werden soll identisch, %TODO TODO Pfad zu Kernelkode im System -> Kein Crosscompiler
Handelt es sich wie im Fall dieser Arbeit um unterschiedliche Plattformen und Kernelversionen, muss der Quelltext der genau passenden Kernelversion, sowie ein Compiler für die Zielplattform geladen werden. Natürlich kann auch direkt auf der Zielplattform, dem Beaglebone entwickelt werden, allerdings aufgrund dessen geringer Leistungsfähigkeit nicht empfehlenswert.

Für die hier verwendete Kernelversion können die Quelltexte wie folgende geladen und kompiliert werden. \texttt{CROSS\_COMPILE} gibt dabei an, welcher (Cross)-Compiler verwendet werden soll.

%TODO fix this
%\begin{listing} [H]
%\caption{Laden der Kernelquellen}
%\label{lst:Kernelsourcen}
%\begin{minted} [frame=lines, framesep=2mm, fontsize=\footnotesize, linenos] {}

%\end{minted}
%\end{listing}
